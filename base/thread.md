# 多线程

##### 多线程

Java多线程三种实现方式：继承Thread类，实现Runnable接口，使用ExecutorService， Callable Future实现有返回值的多线程。

可返回值的任务必须实现Callable接口，执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取Callable任务返回的Object了。

#####优先级反转

由于多线程共享资源，具有最高优先级的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。

比如 A》B》C  A被C阻塞，C被B阻塞，占有资源被挂起，然后一直被挂起不能释放，导致高优先级的A一直不能执行。

解决办法

- 优先级继承

  低优先级的任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级，当高优先级任务由于等待资源被阻塞时，此时资源的拥有者的优先级将会自动被提升；

- 优先级天花板

  将申请某资源的任务优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级。


继承只有当占有资源的低优先级的任务被阻塞时，才会提高占有资源任务的优先级，而天花板，不论是否发生阻塞都提升。



##### 多线程中 Synchronized Atomic Volatile ThreadLocal

- synchronized 解决多线程资源共享问题，同步机制采用了 “以时间换空间”，访问串行化，对象共享化。同步机制是只提供一份变量，让所有线程都可以访问。

- Atomic  通过原子操作指令 + Lock-Free完成，从而实现非阻塞的并发。开销小，速度快比如AtomicInteger中的实现

  ```java
  public final int incrementAndGet() {
    for(;;) {
      int current = get();
      int next = current + 1;
      if (compareAndSet(current, next))
        return next;
    }
  }
  ```

  **final**：final类 不能被集成，虚拟机也会进行优化，比如String是个final类，final修饰函数也是这个意思

  ​	     匿名内部类中所有变量必须都是final的；

  ​	     接口中声明的所有变量本身都是final的；

  ​	     final 和 abstract 两个关键字是反相关，final类就不能是abstract的。

  ​	     final方法在编译阶段绑定，称为静态绑定（static binding）

  ​             final类对象方法都会被JVM优化。

- Volatile，为多线程资源共享问题解决部分需求，在非依赖自身的操作的情况下，变量的改变对所有线程可见。

- ThreadLocal，并不解决多线程资源共享的问题，而是用来提供线程内的局部变量，省去参数传递这个不必要的麻烦，采用“以空间换时间”的方式，访问并行化，对象独享化。ThreadLocal是为每一个线程提供一份独有的变量，各个线程互相不影响。为了避免内存泄漏，ThreadLocal要设置为static，还必须在线程不使用的时候手动remove掉。




##### 乐观锁和悲观锁

悲观锁的并发性不好，假定所有人都会改，因此必须进入必须锁，直到全部修改完为止；

乐观锁，增加并发的次数；

对于长事物而言，悲观锁的开销往往无法承受，而乐观锁机制在一定程度上解决了这个问题，乐观锁，大多是基于数据版本（Version）记录机制实现。何为数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version” 字段来实现。读取数据时，将此版本号一同读出，之后更新时，对此版本加一。此时将提交数据的版本数据与数据库表对应记录的当前版本信息进行对比，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。