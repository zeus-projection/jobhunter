# Java垃圾回收机制

java的GC策略

**分代回收**

分代垃圾回收策略：不同对象的生命周期不一样，因此，不同的生命周期的对象可以采用不同的回收算法，提高回收效率。

- **年轻代（Young Generation）**
  - 所有新生的对象首先都是放在年轻代，年轻代的目标就是尽可能快速收集掉生命周期短的对象。
  - 新生代内存按照8 ：1 ：1的比例分为一个eden区和两个survivor（0，1）区，大部分对象都是在Eden区中生成。回收时先将eden区存活的对象复制到一个survivor0区，然后晴空eden区，当survivor0区放满了，将eden区和0区的存活对象复制到另一个1区，然后清空eden和0区。然后，将0区和1区交换，一直保持1区为空，反复。
  - 当1区不足以存放eden和0区的存活数据的时候，就将存活的对象直接放到老年代。若老年代也满了，就会触发一次Full GC，即新生代和老年代都要进行回收。
  - 新生代发生的GC也被称为Minor GC，Minor GC发生频率比较高（不一定eden满了才触发）
- **年老代（Old Generation）**
  - 在年轻代经历了N次垃圾回收后仍然存活的对象，就会被放到老年代里面，因此，老年代里面存放的都是生命周期较长的对象
  - 内存比新生代也大很多（大概比例为1:2），当老年代内存满了时，触发Major GC，即Full GC。
- **持久代（Permanent Generation）**
  - 用于存放静态文件，比如java的类，方法，持久代对垃圾回收没有显著影响。




**关于循环引用的问题？**：

循环引用GC怎么处理：单纯的引用计数无法处理循环引用带来的问题；

**引用对象遍历** 画重点，这个是处理循环引用的办法，一般都是引用计数和引用对象遍历来结合在一起处理：

垃圾回收器从被称为**GCRoots**的点开始遍历对象，凡是可以达到的点都会标记为存活，堆中不可到达的对象都会标记成垃圾，然后清理掉。GCRoots有下面这些：

- 类，由系统类加载器加载的类。这些类从不会被卸载，他们可以通过静态属性的方式持有对象的引用。注意一般情况下由自定义的类加载器加载的类不能成为GC Roots；
- 线程，存活的线程；
- Java方法栈中的局部变量或者参数；
- JNI方法栈中的局部变量或者参数；
- JNI全局引用；
- 用作同步监控的对象；
- 被JVM持有的对象，这些对象由于特殊目的的不被GC回收。这些对象可能是系统的类加载器，一些重要的异常处理类，一些为处理异常预留的对象，以及一些正在执行类加载的自定义的类加载器。

基于引用对象遍历的垃圾回收器可以处理循环引用，只要涉及到的对象不能从GC Roots强引用可到达，垃圾回收器都会进行清理来释放内存。